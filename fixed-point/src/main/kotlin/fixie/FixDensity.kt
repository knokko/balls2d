// Generated by fixie at 04-09-2024 09:00
package fixie

import java.lang.Math.*

private const val RAW_ONE: UShort = 1000u

@JvmInline
value class FixDensity private constructor(val raw: UShort) : Comparable<FixDensity> {

	override fun toString(): String {
		val intPart = raw / RAW_ONE
		var fractPart = (raw % RAW_ONE).toString().replace("-", "")
		while (fractPart.length < 3) fractPart = "0$fractPart"
		fractPart = ".$fractPart"
		while (fractPart.endsWith('0')) fractPart = fractPart.substring(0 until fractPart.length - 1)
		if (fractPart == ".") fractPart = ""
		return "$intPart$fractPart"
	}

	fun toInt() = (raw / RAW_ONE).toInt()

	fun toLong() = (raw / RAW_ONE).toLong()

	fun toFloat() = toDouble().toFloat()

	fun toDouble() = raw.toDouble() / RAW_ONE.toDouble()

	@Throws(FixedPointException::class)
	operator fun plus(right: FixDensity): FixDensity {
		try {
			return FixDensity(addExact(this.raw, right.raw))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Tried to compute $this + $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun plus(right: Int) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Long) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Float) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun plus(right: Double) = this + from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: FixDensity): FixDensity {
		try {
			return FixDensity(subtractExact(this.raw, right.raw))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Tried to compute $this - $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun minus(right: Int) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Long) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Float) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun minus(right: Double) = this - from(right)

	@Throws(FixedPointException::class)
	operator fun times(right: FixDensity): FixDensity {
		val largeValue = this.raw.toUInt() * right.raw.toUInt()
		return FixDensity(toUShortExact(largeValue / RAW_ONE))
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Int): FixDensity {
		if (right < 0) throw FixedPointException("Negative numbers are not supported")
		try {
			return FixDensity(toUShortExact(multiplyExact(raw.toUInt(), right.toUInt())))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Can't represent $this * $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Long): FixDensity {
		if (right < 0) throw FixedPointException("Negative numbers are not supported")
		try {
			return FixDensity(toUShortExact(multiplyExact(raw.toULong(), right.toULong())))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Can't represent $this * $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun times(right: Float) = this * from(right)

	@Throws(FixedPointException::class)
	operator fun times(right: Double) = this * from(right)

	@Throws(FixedPointException::class)
	operator fun div(right: FixDensity): FixDensity {
		val largeValue = this.raw.toUInt() * RAW_ONE.toUInt()
		try {
			return FixDensity(toUShortExact(largeValue / right.raw))
		} catch (overflow: ArithmeticException) {
			throw FixedPointException("Can't represent $this / $right")
		}
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Int): FixDensity {
		if (right <= 0) {
			throw FixedPointException("Can't represent $this / $right")
		}
		return FixDensity(toUShortExact(raw.toUInt() / right.toUInt()))
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Long): FixDensity {
		if (right <= 0L) {
			throw FixedPointException("Can't represent $this / $right")
		}
		return FixDensity(toUShortExact(raw.toULong() / right.toULong()))
	}

	@Throws(FixedPointException::class)
	operator fun div(right: Float) = this / from(right)

	@Throws(FixedPointException::class)
	operator fun div(right: Double) = this / from(right)

	override operator fun compareTo(other: FixDensity) = this.raw.compareTo(other.raw)

	operator fun compareTo(other: Short) = if (other < 0) 1 else if (other > 65) -1 else this.compareTo(from(other))

	operator fun compareTo(other: UShort) = if (other > 65u) -1 else this.compareTo(from(other))

	operator fun compareTo(other: Int) = if (other < 0) 1 else if (other > 65) -1 else this.compareTo(from(other))

	operator fun compareTo(other: UInt) = if (other > 65u) -1 else this.compareTo(from(other))

	operator fun compareTo(other: Long) = if (other < 0) 1 else if (other > 65) -1 else this.compareTo(from(other))

	operator fun compareTo(other: ULong) = if (other > 65u) -1 else this.compareTo(from(other))
	operator fun compareTo(other: Float) = if (other < 0.0f) 1 else if (other > 65.535f) -1 else this.compareTo(from(other))
	operator fun compareTo(other: Double) = if (other < 0.0) 1 else if (other > 65.535) -1 else this.compareTo(from(other))

	companion object {

		val ZERO = from(0)
		val ONE = from(1)

		fun raw(rawValue: UShort) = FixDensity(rawValue)

		@Throws(FixedPointException::class)
		fun from(value: Short): FixDensity {
			try {
				return FixDensity(multiplyExact(value, RAW_ONE))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		@Throws(FixedPointException::class)
		fun from(value: Int): FixDensity {
			try {
				return from(toUShortExact(value))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		@Throws(FixedPointException::class)
		fun from(value: Long): FixDensity {
			try {
				return from(toUShortExact(value))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		@Throws(FixedPointException::class)
		fun from(value: UShort): FixDensity {
			try {
				return FixDensity(multiplyExact(value, RAW_ONE))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		@Throws(FixedPointException::class)
		fun from(value: UInt): FixDensity {
			try {
				return from(toUShortExact(value))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		@Throws(FixedPointException::class)
		fun from(value: ULong): FixDensity {
			try {
				return from(toUShortExact(value))
			} catch (overflow: ArithmeticException) {
				throw FixedPointException("Can't represent $value")
			}
		}

		fun from(value: Float) = from(value.toDouble())

		@Throws(FixedPointException::class)
		fun from(value: Double): FixDensity {
			val doubleValue = RAW_ONE.toDouble() * value
			if (doubleValue > UShort.MAX_VALUE.toDouble() || doubleValue < UShort.MIN_VALUE.toDouble()) {
				throw FixedPointException("Can't represent $value")
			}
			return FixDensity(kotlin.math.floor(doubleValue + 0.5).toUInt().toUShort())
		}
	}

	@JvmInline
	@OptIn(ExperimentalUnsignedTypes::class)
	value class Array private constructor(val raw: UShortArray) {

		constructor(size: Int) : this(UShortArray(size))

		constructor(size: Int, initializer: (Int) -> FixDensity) : this(UShortArray(size) { index -> initializer(index).raw })

		val size: Int
			get() = raw.size

		operator fun get(index: Int) = FixDensity(raw[index])

		operator fun set(index: Int, value: FixDensity) {
			raw[index] = value.raw
		}

		fun fill(value: FixDensity) {
			raw.fill(value.raw)
		}
	}
}

@Throws(FixedPointException::class)
operator fun Int.plus(right: FixDensity) = FixDensity.from(this) + right

@Throws(FixedPointException::class)
operator fun Long.plus(right: FixDensity) = FixDensity.from(this) + right

@Throws(FixedPointException::class)
operator fun Float.plus(right: FixDensity) = FixDensity.from(this) + right

@Throws(FixedPointException::class)
operator fun Double.plus(right: FixDensity) = FixDensity.from(this) + right

@Throws(FixedPointException::class)
operator fun Int.minus(right: FixDensity) = FixDensity.from(this) - right

@Throws(FixedPointException::class)
operator fun Long.minus(right: FixDensity) = FixDensity.from(this) - right

@Throws(FixedPointException::class)
operator fun Float.minus(right: FixDensity) = FixDensity.from(this) - right

@Throws(FixedPointException::class)
operator fun Double.minus(right: FixDensity) = FixDensity.from(this) - right

@Throws(FixedPointException::class)
operator fun Int.times(right: FixDensity) = right * this

@Throws(FixedPointException::class)
operator fun Long.times(right: FixDensity) = right * this

@Throws(FixedPointException::class)
operator fun Float.times(right: FixDensity) = right * this

@Throws(FixedPointException::class)
operator fun Double.times(right: FixDensity) = right * this

@Throws(FixedPointException::class)
operator fun Int.div(right: FixDensity) = FixDensity.from(this) / right

@Throws(FixedPointException::class)
operator fun Long.div(right: FixDensity) = FixDensity.from(this) / right

@Throws(FixedPointException::class)
operator fun Float.div(right: FixDensity) = FixDensity.from(this) / right

@Throws(FixedPointException::class)
operator fun Double.div(right: FixDensity) = FixDensity.from(this) / right

operator fun Int.compareTo(right: FixDensity) = FixDensity.from(this).compareTo(right)

operator fun Long.compareTo(right: FixDensity) = FixDensity.from(this).compareTo(right)

operator fun Float.compareTo(right: FixDensity) = FixDensity.from(this).compareTo(right)

operator fun Double.compareTo(right: FixDensity) = FixDensity.from(this).compareTo(right)

fun min(a: FixDensity, b: FixDensity) = FixDensity.raw(min(a.raw, b.raw))

fun max(a: FixDensity, b: FixDensity) = FixDensity.raw(max(a.raw, b.raw))
